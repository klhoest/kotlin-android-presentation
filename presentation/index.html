<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Kotlin</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/white.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/github.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<style>
		.bold {
			font-weight: bolder !important;
			color: #FFF;
		}

		.opening {
			position: relative;
			top: -200px;
			left: 20px;
		}
	</style>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background-transition="fade">

				<section data-background="images/android_kotlin.png">
					<h3 class="opening"> Kotlin & Android</h3>
				</section>
				<section>
					<h2>
						Sommaire
					</h2>
					<ul>
						<li>
							Introduction
						</li>
						<li>
							Syntaxe
						</li>
						<li>
							Null Safety
						</li>
					</ul>
				</section>
			</section>

			<section data-background-transition="fade" data-background="#FFD4F1">
				<section data-background-transition="fade" data-background="#c47eb6">
					<h2>Introduction</h2>
				</section>
				<section>
					<h2>
						Kotlin est
					</h2>
					<ul>
						<li>
							Orienté objet et fonctionnel
						</li>
						<li>
							Typage statique
						</li>
						<li>
							Conçu pour s'executer sur la JVM (Android)..
						</li>
						<li>
							..mais aussi pour être compilé sur Linux et convertit en Javascript
						</li>
						<li>
							mélangé avec du code Java et les bibliothèques Java
						</li>
						<li>
							Peut fonctionner avec Java 6+
						</li>
						<li>
							Créé par JetBrains
						</li>
						<!-- ajouter photo wikipedia -->
					</ul>
				</section>
				<section>
					<h2>Les apports du Kotlin par rapport au Java</h2>
					<table     interface Targeting {
						val target: WorkablePlanet?
						val requiredArmy: Int
						var AIFleetOrders: ArrayList<FleetOrder>
						var sentFleetNumber: Int
						fun findTarget(): WorkablePlanet?
						fun mobilise()
						fun itsATrap() {
							AIFleetOrders.clear()
						}
					}
				
					inner class InerTarget : Targeting {
				
						override val target: WorkablePlanet? = findTarget()
						override val requiredArmy: Int
							get() {
								var extraCare = 0
								if(target != null) {
									if (target.colony.owner != WorkablePlanet.Guilde_du_Commerce) {
										extraCare = 5 + target.colony.gr!! * 2
									}
									return extraCare + target.empireFleetIncoming + (target.enemyCivilainNearby - target.rebelCivilianNearby).toInt() - target.rebelionFleetIncoming - sentFleetNumber
								} else {
									return 0
								}
							}
						override var AIFleetOrders = ArrayList<FleetOrder>();
						override var sentFleetNumber: Int = 0
							get() = AIFleetOrders.sumBy { inpectFleet -> inpectFleet.units }
				
						override fun findTarget(): WorkablePlanet? {
							var inspectPlanet: WorkablePlanet
							val it = solarSystemCell.iterator()
							while (it.hasNext()) {
								inspectPlanet = it.next()
								if (!inspectPlanet.safe) {
									System.out.println("innerTarget : " + inspectPlanet.colony.id + " , interest = " + inspectPlanet.interest)
									return inspectPlanet
								}
							}
							System.out.println("no innerTarget found. skip this turn");
							return null
						}
				
						override fun mobilise() {
							if(target != null) {
								println("on innerTarget: " + target.colony.id)
								var mobiliseOverpopulation = false
								for (inspectedPlanet in overPopulatedPlanetList) {
									if (requiredArmy < 0)
										return
				
									sentFleetNumber = inspectedPlanet.pourFrodon(target.colony.id, requiredArmy, AIFleetOrders)
									mobiliseOverpopulation = true;
								}
								val it = sortRebelPlanets.iterator()
								while (requiredArmy > 0 && it.hasNext()) {
									sentFleetNumber += it.next().pourFrodon(target.colony.id, requiredArmy, AIFleetOrders)
								}
								if (requiredArmy > 15 && !mobiliseOverpopulation) {
									itsATrap();
								}
								returnJSON.fleets.addAll(AIFleetOrders)
							}
						}
					}
				
					inner class OuterTarget() : Targeting {
						override val target: WorkablePlanet? = findTarget()
						override val requiredArmy: Int
							get() {
								var extraCare = 0
								if(target!= null) {
									if (target.colony.owner != WorkablePlanet.Guilde_du_Commerce) {
										extraCare = 30 + target.colony.gr!! * 3
									}
									return extraCare + target.empireFleetIncoming + (target.enemyCivilainNearby - target.rebelCivilianNearby).toInt() - target.rebelionFleetIncoming - sentFleetNumber + (distance/70).toInt()
								} else {
									return 0
								}
							}
						override var AIFleetOrders = ArrayList<FleetOrder>();
						override var sentFleetNumber: Int = 0
							get() = AIFleetOrders.sumBy { inpectFleet -> inpectFleet.units }
				
						var distance:Double =99999.0
							get() {
								if(target!= null) {
									return Math.hypot(localCluster.center.x - target.colony.x, localCluster.center.y - target.colony.y)
								}
								else {
									return 99999.0
								}
							}
				
						override fun findTarget(): WorkablePlanet? {
							val cellTargets = TreeMap<Double, WorkablePlanet>()
							AIList.forEach { inspectAI ->
								val targetCopy = inspectAI.inerTarget; //could not smart cast otherwise
								if (targetCopy != null && targetCopy.target!= null) {
									val potentialtarget = targetCopy.target
									val key = (potentialtarget.interest - Math.hypot(localCluster.center.x - potentialtarget.colony.x, localCluster.center.y - potentialtarget.colony.y) / 40) * -1
									cellTargets.put(key, potentialtarget)
								}
							}
							if (cellTargets.isEmpty()) {
								System.out.println("no outerTarget found. skip this turn");
								return null
							} else {
								return cellTargets.firstEntry().value
							}
						}
				
						override fun mobilise() {
							if(target!= null) {
								println("on outerTarget: " + target.colony.id)
								var mobiliseOverpopulation = false
								for (inspectedPlanet in overPopulatedPlanetList) {
									if (requiredArmy < 0)
										return
									sentFleetNumber = inspectedPlanet.pourFrodon(target.colony.id, requiredArmy, AIFleetOrders)
									mobiliseOverpopulation = true;
								}
								val it = sortRebelPlanets.iterator()
								while (requiredArmy > 0 && it.hasNext()) {
									sentFleetNumber += it.next().pourFrodon(target.colony.id, requiredArmy, AIFleetOrders)
								}
								if (requiredArmy > 0 && !mobiliseOverpopulation) {
									itsATrap();
								}
									returnJSON.fleets.addAll(AIFleetOrders)
							}
						}
					}
				}>
						<tr>
							<td>
								<ul>
									<li>
										Lambda expressions + Inline functions
									</li>
									<li>
										Extension functions
									</li>
									<li>
										Null-safety
									</li>
									<li>
										Smart casts
									</li>
									<li>
										String templates
									</li>
									<li>
										Properties
									</li>
									<li>
										Primary constructors
									</li>
									<li>
										First-class delegation
									</li>
								</ul>
							</td>
							<td>
								<ul>
									<li>
										Data classes
									</li>
									<li>
										Type inference for variable and property types
									</li>
									<li>
										Declaration-site variance & Type projections</li>
									<li>
										Range expressions
									</li>
									<li>
										Operator overloading
									</li>
									<li>
										Companion objects
									</li>
									<li>
										Separate interfaces for read-only and mutable collections
									</li>
									<li>
										Coroutines
									</li>
								</ul>
							</td>
						</tr>
					</table>
				</section>
				<section>
						<h2>Java 8 from Scratch?</h2>
				</section>
				<section>
					Basé sur les problématique rencontrées lors de la création de l'IA de l'hackathon OnePoint
					<img src="images/stream.png" />
				</section>
			</section>
			<section data-background-transition="fade" data-background="#C8EDFF">
				<section data-background-transition="fade" data-background="#87bae1">
					<h2>Language syntax</h2>
				</section>
				<section>
					<h2>
						Functions
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
fun sum(a: Int, b: Int): Int {
    return a + b
}
					</code></pre>

					<pre><code class="hljs" data-trim contenteditable>
fun sum(a: Int, b: Int) = a + b
					</code></pre>

					<pre><code class="hljs" data-trim contenteditable>
fun main(args : String) {
   println("Hello world!")
}
					</code></pre>
				</section>


				<section>
					<h2>
						Functions features
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
fun configure(min: Int = 5, max: Int = 10) {
	/* function with default arguments */
}
// call
configure(max= 20)

					</code></pre>

					<pre><code class="hljs" data-trim contenteditable>
fun concatStrings(vararg values: String): String {
	/* values is collection of strings */
}
					</code></pre>
				</section>
				<section>
					<h2>
						Defining local variable
					</h2>
					Assign-once (read-only) local variable:
					<pre><code class="hljs" data-trim contenteditable>
val a: Int = 1  // immediate assignment
val b = 2   // `Int` type is inferred
val c: Int  // Type required when no initializer is provided
c = 3       // deferred assignment
					</code></pre> Mutable variable:
					<pre><code class="hljs" data-trim contenteditable>
var x = 5 // `Int` type is inferred
x += 1
					</code></pre>
				</section>

				<section>
					<h2>
						Using string templates
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
// c# 6
var a = 1
val s1 = "a is $a"
val s2 = "s1 length = ${s1.length}"
					</code></pre>
				</section>

				<!-- removed features that were too similar with java -->

				<section>
					<h2>
						Ranges
					</h2>
					<pre><code class="hljs" data-trim contenteditable>// iterate through ranges
for (x in 1..5) { print(x) }
for (x in 1..10 step 2)  { print(x) }
for (x in 9 downTo 0 step 3)  { print(x) }

// Check if a number is in or out of range:
if (x in 1..y+1) {
	println("fits in range")
}
if (-1 !in 0..list.lastIndex) {
	println("-1 is out of range")
}</code></pre>
				</section>
				<section>
					<h2>
						When Expression
					</h2>
					(Switch with pattern matching c# 7)
					<pre><code class="hljs" data-trim contenteditable>
fun describe(obj: Any): String =
when (obj) {
    1          -> "One"
    2,3,4      -> "More than one less than 5"
    5..10      -> "Is in range"
    "Hello"    -> "Greeting"
    is Long    -> "Long"
    !is String -> "Not a string"
    else       -> "Unknown"
}				</code></pre>
				</section>

				<!-- removed features that were too similar with java -->

				<section>
					<h2>
						Classes
					</h2>
					<pre><code class="hljs" data-trim contenteditable>// class with default consstructor
class Human { }
// class with primary constructor
class Person(val firstName: String, var lastName: String) { } 
// class with primary constructor
class Customer(val login: String) {
    init { 
	// initializer
    }
    constructor(login: String, val email: String): this(login) {
	//secondary constructor
    }
}</code></pre>
					<pre><code class="hljs" data-trim contenteditable>val human = Human()
val customer1 = Customer("Smith89")
val customer2 = Customer("Smith89", "Joe")</code></pre>
				</section>
				<section>
					<h2>
						Interfaces
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
interface FooBarInterface {
	fun bar()
	fun foo() {
		// Default Interface Implementations (c# 8)
	}
}

</code></pre>
				</section>


				<section>
					<h2>
						Inheritance
					</h2>
					<pre><code class="hljs" data-trim contenteditable>abstract class Controller {
    abstract fun init()
}
open class BaseController: Controller() {
    override fun init()  { /* ... */ }
    open fun onActivated { /* ... */ }
}
interface NavigationAware {
    fun navigateTo(destination: String)
}
class DashboardController : BaseController(), NavigationAware {
    override fun onActivated() { /* ... */ }
    overrider fun navigateTo(destination: String)  { /* ... */ }
}</code></pre>
				</section>

				<!-- removed sections that were not used during the hackathon -->

				<section>
					<h2>
						Properties
					</h2>
					<pre><code class="hljs" data-trim contenteditable>class Test {
private val privateProperty: String = "Private"

var propertyWithCustomAccessors: String
	get() = this.toString()
	set(value) {
		// do something
	}

var propertyWithInitialiserAndBackingField = 0 
	set(value) {
		if (value >= 0) field = value
	}
}</code></pre>
				</section>

				<section>
					<h2>
						Class & members features
					</h2>
					<ul>
						<li>Classess and members are sealed by default unless marked as abstract or open</li>
						<li>Members are public by default unless marked as internal, protected, private</li>
						<li>No static members</li>
					</ul>
				</section>

				<section>
					<h2>
						Data classes
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
//c# 8 records
data class User(val name: String, val age: Int)
						</code></pre> The compiler automatically creates:
					<ul>
						<li>equals()/hashCode()</li>
						<li>toString()</li>
						<li>componentN()</li>
						<li>copy()</li>
					</ul>
				</section>
			</section>

			<section data-background-transition="fade" data-background="#FFE3CE">
				<section data-background-transition="fade" data-background="#e1a172">
					<h2>
						Advanced features
					</h2>
				</section>

				<!-- removed sections that were not used during the hackathon -->

				<section>
					<h2>
						Lambdas
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
//no parameters lambda
defer { notify() }

//lambda with parameters
max(strings, { a, b -> a.length < b.length })

//it: implicit name of a single parameter
strings
.filter { it.length == 5 }
.sortBy { it }
.map { it.toUpperCase() }
			</code></pre>
				</section>

				<section>
					<h2>
						Collections lambda expressions
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
fruits
.filter { it.startsWith("a") }
.sortedBy { it }
.map { it.toUpperCase() }
.forEach { println(it) }
							</code></pre>
				</section>

				<section>
					<h2>
						Higher-Order Functions
					</h2>
					A higher-order function is a function that takes functions as parameters, or returns a function
					<pre><code class="hljs" data-trim contenteditable>fun lock(lock: Lock, body: () -> Unit): Unit {
	lock.lock()
	try {
		return body()
	}
	finally {
		lock.unlock()
	}
}</code></pre>

					<pre><code class="hljs" data-trim contenteditable>fun toBeSynchronized() = sharedResource.operation()
val result = lock(lock, { sharedResource.operation() })</code></pre>
				</section>

				<section>
						<h2>
							Using conditional expressions
						</h2>
						<pre><code class="hljs" data-trim contenteditable>
	fun maxOf(a: Int, b: Int): Int {
		if (a > b) {
			return a
		} else {
			return b
		}
	}
						</code></pre> if expression ( ? : ; in c# )
						<pre><code class="hljs" data-trim contenteditable>
	fun maxOf(a: Int, b: Int) = if (a > b) a else b
						</code></pre>
					</section>


				
				<!-- removed sections that were not used during the hackathon -->


			</section>

			<!-- removed Android section -->

			<!-- removed section nammed problem --> 

			<!-- removed section nammed More info -->

			<section data-background-transition="fade" data-background="#FFF">
				<section>
					<h2>Null Safety</h2>
				</section>
				<section>
					<h2>Les références. Plus sûres et plus restrictives</h2>
					<img src="images/Pointers5.png" />
				</section>

				<section>
					<h2>Opérations possibles sur une référence</h2>
						<div style="text-align: left; float: left; font-size: 20px">
							<ol>
								<li>
									La faire pointer sur un objet existant
								</li>
								<li>
									La faire pointer à l’adresse null
								</li>
								<li>
									Lire l’objet pointé
								</li>
								<li>
									Écraser l’objet pointé
								</li>
								<li>
									Accéder à un membre de l’objet pointé 
								</li>
							</ol>
					  </div>
					  <div style="text-align: right; float: right;">
							<img src="images/reference.png" />
						</div>
				</section>

				<section>
					<h2>
						Distinction entre les types nullables et les types non-nullables
					</h2>
					<pre><code class="hljs" data-trim contenteditable>
var a: Sting = "abc"
a = null // erreur de compilation ici
var l = a.length

var b: String? = "abc"
b = null
val l = b.length // erreur de compilation ici
</code ></pre>
				</section>

				<section>
						<h2>
							Null-safety
						</h2>
						<pre style="max-height: 550px;"><code class="hljs" data-trim contenteditable>
interface Targeting {
	val target: WorkablePlanet?
	val requiredArmy: Int
	var AIFleetOrders: ArrayList<FleetOrder>
	var sentFleetNumber: Int
	fun findTarget(): WorkablePlanet?
	fun mobilise()
	fun itsATrap() {
		AIFleetOrders.clear()
	}
}

inner class InerTarget : Targeting {

	override val target: WorkablePlanet? = findTarget()
	override val requiredArmy: Int
		get() {
			var extraCare = 0
			if(target != null) {
				if (target.colony.owner != WorkablePlanet.Guilde_du_Commerce) {
					extraCare = 5 + target.colony.gr!! * 2
				}
				return extraCare + target.empireFleetIncoming + (target.enemyCivilainNearby - target.rebelCivilianNearby).toInt() - target.rebelionFleetIncoming - sentFleetNumber
			} else {
				return 0
			}
		}
	override var AIFleetOrders = ArrayList<FleetOrder>();
	override var sentFleetNumber: Int = 0
		get() = AIFleetOrders.sumBy { inpectFleet -> inpectFleet.units }

	override fun findTarget(): WorkablePlanet? {
		var inspectPlanet: WorkablePlanet
		val it = solarSystemCell.iterator()
		while (it.hasNext()) {
			inspectPlanet = it.next()
			if (!inspectPlanet.safe) {
				System.out.println("innerTarget : " + inspectPlanet.colony.id + " , interest = " + inspectPlanet.interest)
				return inspectPlanet
			}
		}
		System.out.println("no innerTarget found. skip this turn");
		return null
	}

	override fun mobilise() {...}
}
						
						</code></pre>
					</section>

					<section>
						<h2>
							Valeur par défaut
						</h2>
						<pre><code class="hljs" data-trim contenteditable>
private var rebelInside: Int? = null
get() {
	return aIToPlanet?.getRebelInCluster()
}
private val minPop: Int
	get() {
		val temp = Integer.min(maxPop, max(empireFleetIncoming - rebelionFleetIncoming, 0) + alreadySentFleet + 1 - (rebelInside ?: 0) / 7)
		return Integer.max(temp, 1)
	}
private var alreadySentFleet: Int = 0
public var aIToPlanet: AItoPlanet? = null
						</code ></pre>
					</section>

			</section>

		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [{
				src: 'plugin/markdown/marked.js'
			},
			{
				src: 'plugin/markdown/markdown.js'
			},
			{
				src: 'plugin/notes/notes.js',
				async: true
			},
			{
				src: 'plugin/highlight/highlight.pack.js',
				async: true,
				callback: function () {
					hljs.initHighlightingOnLoad();
				}
			}
			]
		});
	</script>
</body>

</html>